-------------------------------------------------------------------------------
MODELING
-------------------------------------------------------------------------------
  A container for all the entities which we use
  Robot, Terrain, RigidObject, MultiPath
  EntryFile: World.h
  
  Note: 
    Robot corresponds to the "desired" yellowish robot in simulation; to put
    the real robot exactly at a position can be done over ODERobot
    WorldSimulation->GetRobot(). This is only for starting purposes of course.
    Control acts on ODEWorldSimulationRobot, while all the kinematic
    solutions/setconfig act on Yellow Robot. 
    Be sure to update the frames or use UpdateConfig to set the robot
-------------------------------------------------------------------------------

RobotWorld (World.h) contains 
  Robot, Terrain, RigidObject, MultiPath!
  Names, Ids
  Load/Save XML

World -> Terrain -> ManagedGeometry -> DrawGL()
-> GLDraw::GeometryAppearance -> DrawGL() ->
  

Robot (Modeling/Robot.h)
bool InJointLimits(const Config& q) const;
virtual bool SelfCollision(Real distance=0);


  Robot : public RobotWithGeometry
    string name;
    vector<string> geomFiles;   ///< geometry file names (used in saving)
    vector<ManagedGeometry> geomManagers; ///< geometry loaders (speeds up loading)
    Vector accMax;   ///< conservative acceleration limits, used by DynamicPath
    vector<RobotJoint> joints;
    vector<RobotJointDriver> drivers;
    vector<string> linkNames;
    vector<string> driverNames;

  <- RobotWithGeometry

    SelfCollision()
    DrawGL()
    DrawLinkGL(int i)
    int LinkIndex(char *) GetBody|GetLink function
    virtual bool SelfCollision(Real distance=0);


  <- <- RobotDynamics3D 

    Vector dq;   ///< current velocity
    Vector velMin,velMax; ///< velocity limits
    Vector torqueMax;     ///< torque limits
    Vector powerMax;      ///< Power=|torque||velocity| limits

    //B*ddq + C*dq = fext
      //ddq from fext
      void CalcAcceleration(Vector& ddq, const Vector& fext);
      //fext from ddq
      void CalcTorques(const Vector& ddq, Vector& fext);


  <- <- <- RobotKinematics3D 

    Vector3 GetCOM()
    GetTotalMass()
    std::vector<RobotLink3D> links;
    Config q;  //! DO NOT set directly, use UpdateConfig!
    Vector qMin,qMax;   ///< joint limits

    /// sets the current config q and updates frames
    void UpdateConfig(const Config& q);
    /// based on the values in q, update the frames T
    void UpdateFrames();
    bool InJointLimits(const Config& q) const;

    //Force Field acts on rigid link i and induces a wrench on its COM
    // wrench on COM of link i induces a wrench on CS of robot. 
    // F = J^t w | w=(torque,force)
    void GetWrenchTorques(const Vector3& torque, const Vector3& force, int i, Vector& F) const;


  <- <- <- <- Chain
    //on-chain/off-chain idea goes here:
    void GetChildList(std::vector<std::vector<int> >& children) const;


RobotLink3D (KrisLibrary/robotics/RobotLink3d.h
  Type type; {revolute,prismatic}
  Vector3 w;
  Real mass;
  Vector3 com;
  Matrix3 inertia;

-------------------------------------------------------------------------------
INTERFACE
-------------------------------------------------------------------------------

  Controls the communication between frontend and backend
  Frontend  (The GUI, viewer, interactions, dynamic simulation, drawGL)
    GenericGUIBase (GenericGUI.h)
  Backend (The world and its entities)
    GenericBackendBase (GenericGUI.h)

-------------------------------------------------------------------------------
BACKEND [Interface/*GUI.h]
-------------------------------------------------------------------------------
  GenericBackendBase [GenericGUI.h] 
    bool GenericGUIBase::SendGLViewport(int x,int y,int w,int h)

  <- MouseDragBackend [NavigationGUI.h] 
  <- <- GLNavigationBackend [NavigationGUI.h] 
          Camera::Viewport viewport; viewport.x .y .w .h 
          OnGLRender()
            RenderWorld()

  <- <- <- WorldGUIBackend [WorldGUI.h] (loader for RobotWorld)
              RenderWorld()
                drawCoords(0.1);

  <- <- <- <- SimGUIBackend [SimulationGUI.h] (add functions to display dynamics,i.e. wrenches, torques, contacts etc)
                RenderWorld()
                  world->terrains[i]->DrawGL();
                  world->rigidObjects[i]->DrawGL();
                  world->robotViews[i].DrawLink_World(j);

  <- <- <- <- <- SimTestBackend [SimTestGUI.h] (more functions to interact with robot, add forces, etc)
                  RenderWorld()
                    world->robotViews[r].SetColors(desiredColor);
                    world->robotViews[r].Draw();
                    world->robotViews[r].SetAppearance(oldAppearance);

-------------------------------------------------------------------------------
GUI
-------------------------------------------------------------------------------
  GLUIProgramBase [KrisLibrary/GLdraw/GLUIProgram.h]
  Run()
  int Run(const char *window_title="OpenGL Viewer",unsigned int displayMode=0);

  <- GLUIGUI : GenericGUIBase, GLUIProgramBase [Interface/GLUIGUI.h]

  <- <- GLScreenshotProgram<BaseGUI> : public BaseGUI

  <- <- <- GLUISimTestGUI : GLScreenshotProgram<GLUIGUI>
          Initialize()








adding new widgets: 
Creating button: 
Connecting button: button has to be connected with render drawing method => MapButtonToggle("draw_bbs",&drawBBs);


%%inline void DrawGLTris(const
%%                                                                                                              
%%{
%%  glBegin(GL_TRIANGLES);
%%  for(size_t i=0;i<mesh.tris.size();i++) {
%%  | Math3D::Vector3 normal =
%%  | glNormal3v(normal);
%%  | glVertex3v(mesh.verts[mesh.tris[i].a]);
%%  | glVertex3v(mesh.verts[mesh.tris[i].b]);
%%  | glVertex3v(mesh.verts[mesh.tris[i].c]);
%%  }
%%  glEnd();
%%}





-------------------------------------------------------------------------------
VIEW
-------------------------------------------------------------------------------
  drawing routines for all entities defined in RobotWorld
-------------------------------------------------------------------------------

Actual drawing happens in KrisLibrary/GLdraw/GeometryAppearance.cpp
KrisLibrary/GLdraw/drawextra.h

-------------------------------------------------------------------------------
SIMULATION
-------------------------------------------------------------------------------
  ode simulation files 
  everything related to the actual dynamical simulation
  EntryFile : WorldSimulation.h
-------------------------------------------------------------------------------

WorldSimulation
  double time

  /// anything contact forces/torques, where are the contacts etc goes here
  ODEContactList* GetContactList(int aid,int bid);
  Vector3 ContactForce(int aid,int bid=-1);

  // major players
  ODESimulator odesim; //your gateway to ODE geometrix
  RobotWorld *world;

  ODERobot GetRobot(int id); //get the real robot (you cannot and should not
    control that, but can be used for initial placement procedures)

-------------------------------------------------------------------------------
CONTACTS
-------------------------------------------------------------------------------

  Hold (a single robot link-env contact with 1 or more contact points)
  Stance (a set of holds)
  Grasp (a set of holds with some dofs fixed)

-------------------------------------------------------------------------------
CSPACE
-------------------------------------------------------------------------------

  CSpace (Krislibrary/planning/cspace.h)
    //Generic CSpace
    void Sample(Config& x);
    bool IsFeasible(const Config&);

  <- ExplicitCSpace (KrisLibrary/planning/ExplicitCspace.h)
    //N-obstacles CSpace
    bool IsFeasible(const Config&,int obstacle);
    EdgePlanner* LocalPlanner(const Config& a,const Config& b,int obstacle);
    int NumObstacles();
    void GetInfeasibleNames(const Config& q,std::vector<std::string>& names);

  <- <- SingleRobotCSpace  (Klampt/Planning/RobotCSpace.h)
    //Single Robot 
    vector<pair<int,int> > collisionPairs;
    bool CheckCollisionFree();
    WorldPlannerSettings* settings;
    RobotWorld& world;
    int index; ##robot number
    Robot* GetRobot&();


  <- <- <- <- SingleRobotCSpace2 (Klampt/Planning/RobotCSpace.h)
    //Single robot + fixed dofs available
    IgnoreCollisions(int,int)
    FixDof(int,double)

  <- <- <- <- <- ContactCSpace (Klampt/Planning/ContactCSpace.h)
    //Single Robot in contact with environment
    vector<IKGoal> contactIK;
    void AddContact(const IKGoal& goal);
    void RemoveContact(int link);
    bool SolveContact(int numIters=0,Real tol=0);
-------------------------------------------------------------------------------
KINODYNAMIC CSPACE
-------------------------------------------------------------------------------

  CSpace (Krislibrary/planning/cspace.h)
    void Sample(Config& x);
    bool IsFeasible(const Config&);

  <- KinodynamicCSpace (KrisLibrary/planning/KinodynamicCSpace.h)

  <- <- IntegratedKinodynamicCSpace : public KinodynamicCSpace


-------------------------------------------------------------------------------
MOTION PLANNER
-------------------------------------------------------------------------------

(KrisLibrary/planning/MotionPlanner.h)

RoadmapPlanner 
TreeRoadmapPlanner
  <- RRTPlanner
  <- <- BidirectionalRRTPlanner

(KrisLibrary/planning/AnyMotionPlanner.h)
  MotionPlannerFactory factory;
  factory.type="rrt"
  MotionPlannerInterface = factory.create(CSpace)




-------------------------------------------------------------------------------
LOAD/SAVE RESOURCE (KrisLibrary/utils/ResourceLibrary.h)
-------------------------------------------------------------------------------

  Modeling/Resources.h

    BasicResources (vector,transform,config)
    GraspResources

-------------------------------------------------------------------------------
MATH
 * The elements can be accessed as (i,j) for i,j in [0,3].

  WARNING: [i][j] = (j,i) !! DO NOT USE [i][j]
-------------------------------------------------------------------------------
 Infinity
  double dInf
  Real Inf

 Krislibrary/math3d/primitives.h
  class Vector2;
  class Vector3;
  class Vector4;
  class Matrix2;
  class Matrix3;
  class Matrix4;
  class RigidTransform2D;
  class RigidTransform;
  +IO functionality!

  - class Matrix3
    inline void setRotateX(Real rads);  ///<sets the matrix that rotates ccw by rads around the x axis
    inline void setRotateY(Real rads);  ///<sets the matrix that rotates ccw by rads around the x axis
    inline void setRotateZ(Real rads);  ///<sets the matrix that rotates ccw by rads around the x axis

  setIdentity()
  setZero()


 Krislibrary/math/Vectortemplate.h
  typedef class VectorTemplate<float> fVector;
  typedef class VectorTemplate<double> dVector;
  typedef class VectorTemplate<Complex> cVector;
  typedef VectorTemplate<Real> Vector;
    T dot(const MyT&) const;
    T dotSelf() const;
    T norm() const;
    T normSquared() const;
    T distance(const MyT&) const;
    T distanceSquared(const MyT&) const;
    T minElement(int* index=NULL) const;
    T maxElement(int* index=NULL) const;
    T minAbsElement(int* index=NULL) const;
    T maxAbsElement(int* index=NULL) const;

-------------------------------------------------------------------------------
PATH
-------------------------------------------------------------------------------

MilestonePath (KrisLibrary/planning/path.h)
  const Config& Start()
  const Config& End()
  bool IsFeasible();
  int Eval(Real t, Config& c) const;

MultiPath (Modeling/MultiPath.h)
  Load(string);
  Save(string);
  bool IsValid();
  Real StartTime() const;
  ///Returns the end time of the path.  If untimed, the end time is 1.
  Real EndTime() const;
  Real Duration() const;
  int Evaluate(Real time,Vector& q,Vector& v)


-------------------------------------------------------------------------------
TODO
-------------------------------------------------------------------------------

 [x] solve IK for frame-env contact points
 [x] Can't change SIMROBOT anymore, what happened!?
 [x] place robot directly(!) at IK computed solution and THEN start sim 
 [x] place robot feet on floor
 [x] plan path between A and B
 [x] extract milestones between A and B from path
 [x] execute path in GUI
 [x] retime path
 [x] execute trajectory in GUI
 [x] add limits/selfcollision/collision checks to IK
 [x] visualize path in GUI (i.e. visualize the individual link paths)
 [x] swept volume? (for irr paper)
 [x] swept volume transparent without the blueish background
 [x] Move hand such that a set of fingertip points is fulfilled
 [x] set color to link in contact
 [x] importing/exporting blender models? how to best design your own environments? [needs .tri to blender importer. there is none (only for some other tri files). maybe better to convert to dae (collada) ?]
 [x] why does planning fail with 1 additional joint see sentinel
 [x] disable backface culling to display backoriented triangles (just use rigidobject, they are non-culled)
 [x] MultiPath is using linear interpolation between keyframes. However on SO(3)
we need a different interpolation due to the gluing of the charts. Check if
something like that is already implemented, see GeodesicManifold/DynamicPath.
Just use KinodynamicMilestonePath instead of MultiPath!
 [x] add widgets for planning to gui
 [x] setup kinodynamic planning problem
 [x] control in kinodynamic planning converges to wrong direction
 [x] refactor draw methods in gui.cpp
 [ ] solve IK for arbitrary rob-env contact points
 [ ] grasp an actual object
 [ ] sample grasps for object and compute IK (findGrasp method)
 [ ] make/break contact events => compute transition paths
 [ ] execute transition paths 
 [ ] change viewpoint internally
 [ ] Compute Force Closure Grasp from points
 [ ] Compute SE constraints, what is GIWC equivalent?
 [ ] smoothing after path planning
 [ ] make a Klampt Interface where to set all properties like background color etc
 [x] screenshots x_X?
 [ ] refactor kinodynamic planner to make it independent from path planner
 [x] refactor planner settings
 [x] save kinodynamicmilestonepath to file 
 [x] outsource serialized tree to seperate file
 [x] save motion planner class plus tree and path
 [x] krrt: no forward simulation towards goal (was wrong init rot)
 [x] save/load GUI state including Motion Planning Equipment
 [x] Display/Undisplay Rigid Bodies (to visualize tree)
 [x] implement edge visualization in KrisLibrary/GLDraw/GeometryAppearance.cpp
 [x] install krislib with ompl support (didn't link ompl in klampt lib and this lib)
 [x] ompl does not read the joint limits
 [x] make ompl planners available 
 [ ] add directions again in draw serialized tree after culling nodes
 [ ] remove this orange line from origin to p_init
 [ ] Button to save/load GUI state including Motion Planning Equipment
 [x] ompl converts cspace to realvectorspace R, but we need a compound space SE(3)xQ => make own ompl interface
 [x] enable ompl geometric planners
 [x] add omplapp interface to load meshes + collision detection (check omplapp/SE3RigidBodyPlanning.cpp)
      (/git/ompl/omplapp-1.3.0-Source/demos/SE3RigidBodyPlanning)
 [x] enable ompl kinodynamic planners
 [ ] create planner_klampt outsourcing klampt planning structure
 [x] move planner components to planner/
 [x] make button to disable/enable mesh and disable/enable faces of mesh
 [x] run ompl PDST/KPIECE /w def proj
 [x] compute irreducible projection from SE(3) path

 [x] GUI: save current robot state too, not only init/goal of planner
 [x] remove torsion while computing irreducible projection
 [x] reimplement irreducible projection in cpp, make it cleaner
 [x] refactor path_pwl_euclid
 [x] compute projection irreducible for N branches
 [x] extend environment by a new pipe upward curved plus box connector
 [x] make the environment easier to compute for rigid body planning (widen the inner hole maybe!?)
 [x] outsource swept volume to seperate elements file
 [x] check distance function in OMPL -- why is it different depending on number of DOFs?
 [ ] boost graph instead of serialized tree?
 [x] find distance to goal for planner output OMPL (how approximate is the solution)
 [x] toggle mesh/faces of objects with keyboard
 [x] add edges to planner tree visualization
 [ ] create sweptvolumeGUI + forcefieldGUI 
 [ ] save all swept volumes when saving GUI, rewrite all Load/Save functions
 [ ] refactor planner -> use PlannerOutput to store path/roadmap and use
PlannerOutput as Input to GUI to shadow the internal things. Also put the
plannersettings into the xml, so that we can load planner+start/goal config
without recompiling. Delete the whole plannersetup folder!
 [ ] enbable/disable swept volume of certain links.
 [ ] better swept volume visualization (have an aggregate or convex hull of successive positions)
      andreas dziegielewski http://acg.cs.tau.ac.il/projects/swept-volume/project-page seems promising
 [ ] use TAB to access different modes: simulation <-> Desired Pose (change goal) blender-like controls?

-- abstractions (longterm goals)

 [ ] Needs switch to QT, the file loader from GLUI seems not to work properly. Also the graphics are quite bad. 
 [x] be able to design landscapes/fancy environments and import them to simulator

 [ ] be able to load different landscapes/robots from simulator, plus start/goal
configs, and be able to run different algorithms to find a solution. Then be
able to save/delete solution paths. So that we can display several output paths
as swept volumes simultaneously
      [ ] be able to load different landscapes + plannersettings from simulator 
      [x] screenshots
      [x] display plannersettings (text+start/goal configs)

 [ ] do benchmark planning from inside the simulator by clicking together
algorithms and #runs and duration. Have a default benchmarking plus dump
everything to nice pdf graph / latex table.
 [ ] have ability to retime a path inside simulator, then display the
output over time inside the simulator. 
 [ ] be able to deform path inside simulator. Ability to load paths from file,
then display them, then deform them, then to save those paths. 
 [ ] visualize planner tree with millions of nodes without lags (cull points somehow)
 [ ] have vim-keybindings to quickly move around, save/load, screenshots,
display tree/start/goal/swept volumes, do planning
 [ ] EnvironmentLoader should be merged with Backend, so that we can load/save inside

-- wrench fields

 [ ] make the controller work without gravity on SE(3)
 [ ] execute kinodynamic path
 [ ] visualize path speed profile

-- irreducible paths

 [x] bug: robot makes backward movements through pipe segment? (check propagate
function)
 [x] repair rotation conversion klampt->klampt
 [x] seems rot of path is right, visualization seems wrong, especially it
diverges near the end of the path
 [x] do ompl planning for N branches (use trivial control)
 [x] ompl benchmark (100 runs à 3600 seconds x environments x 2 x PDST/KPIECE/RRT/SST?)
 [x] Stop if reached goal region
 [x] Check why approximateSolution is false in between planning
 [x] ProblemDefPtr is not updated from ompl site!? (only after last plan?)
 [x] Save every path for every ompl benchmark run, so that we can compare them!? Implement PostSolve 
 [x] Resolve collision of start/goal states of complete model (likely wrong
model?) -> one of the cylinders pierced the head sphere creating a spurious collision
 [x] function createBranchSegment creates collision
 [x] probably bug in postprocess event of benchmark
 [x] display two paths in different colors, one irreducible (magenta or green?), one reducible (red?)
 [x] repeat Nbranch experiments because wrong stepsize was used!
 [x] repeat irreducible experiments using updated curvature!
 [x] repeat experiments with 20 min time frame? (todo)
 [x] repeat experiments with 20 min time frame, curvature = 2.22 and propagation step size in [0.01,0.1] (running)
 [x] experiment 3d snake underwater, 20min, curvature = 1.57, propagation step size [0.01,0.1] (todo)
 [x] experiment 3d snake underwater, 20min (todo)
 [x] design one turbine scenario with a large room (which can be used for wrench planning)
 [x] add one hard experiment where the method will break down, should be short so that any RRT can find a solution under 3600 seconds. 
 [x] outsource planner setup to JSON file or xml (should be loadable in simulator)
 [ ] make irreducible planner independent from xml file (use same xml file, but
if specified irreducible planner, use that one)
 [ ] rewrite introduction and experimental part
 [ ] make sure that cbounds gives an exception if outer limit index
 [ ] what about the humanoid experiments? could we repeat them easily?
 [ ] one humanoid experiment: flat floor, multiple doors at different angles, sideways motion.  Maybe like the kyoto tori 
 [ ] be able to sample all possible IK configurations given contacts
 [ ] CoM + IK computation?

-- important
 [x] loading urdf robots from terrain folder not working
 [ ] update to klampt-0.7
 [ ] visualize wrench cone at contact
