-------------------------------------------------------------------------------
MODELING
-------------------------------------------------------------------------------
  A container for all the entities which we use
  Robot, Terrain, RigidObject, MultiPath
  EntryFile: World.h
  
  Note: 
    Robot corresponds to the "desired" yellowish robot in simulation; to put
    the real robot exactly at a position can be done over ODERobot
    WorldSimulation->GetRobot(). This is only for starting purposes of course.
    Control acts on ODEWorldSimulationRobot, while all the kinematic
    solutions/setconfig act on Yellow Robot. 
    Be sure to update the frames or use UpdateConfig to set the robot
-------------------------------------------------------------------------------

RobotWorld (World.h) contains 
  Robot, Terrain, RigidObject, MultiPath!
  Names, Ids
  Load/Save XML

World -> Terrain -> ManagedGeometry -> DrawGL()
-> GLDraw::GeometryAppearance -> DrawGL() ->
  
Jacobian:
  void GetCOMJacobian(Matrix& Jc) const;
  void GetCOMHessian(Matrix& Hx,Matrix& Hy,Matrix& Hz) const;

  void GetDriverJacobian(int driver,Vector& J);

  /// Computes the time derivative of dpi/dqj.
  /// That is, the jacobian of pi on link i with respect to qj.
  bool GetJacobianDt(const Vector3& pi, int i, int j, Vector3&dtheta_dt,Vector3& dp_dt) const;
  ///gets the jacobian of pi w.r.t qj
  bool GetJacobian(const Vector3& pi, int i, int j, Vector3& dw, Vector3& dv) const;
  bool GetOrientationJacobian(int i, int j, Vector3& dw) const;
  bool GetPositionJacobian(const Vector3& pi, int i, int j, Vector3& dv) const;
  ///gets the jacobian matrix of pi w.r.t q
  ///row 0-2 are angular, 3-5 are translational
  void GetFullJacobian(const Vector3& pi, int i, Matrix& J) const;
  ///rows 3-5 of the above
  void GetPositionJacobian(const Vector3& pi, int i, Matrix& J) const;


struct RobotJointDriver
  enum Type { Normal, Affine, Translation, Rotation, Custom };
  int NumControls() const;  //number of input controls
  int NumLinks() const;
  Type type;
  vector<int> linkIndices;
  Real qmin,qmax;           //min/max values
  Real vmin,vmax;           //min/max velocities
  Real amin,amax;           //min/max accelerations
  Real tmin,tmax;           //min/max torques
  Real servoP,servoI,servoD;  //servo parameters
  Real dryFriction;           //constant friction coefficient
  Real viscousFriction;       //velocity-dependent friction coefficient

class RobotLink3D
  ///links's transformation is a function of control qi
  ///say we're link i
  ///T(i->i)(qi) = R(w*qi)oT(v*qi) where R rotates about an axis, T translates
  ///T(i->pi)(qi) = T0(i->pi)*T(i->i)(qi)
  void GetLocalTransform(Real qi,Frame3D& T) const;

  ///velocity of a point (in frame 0) with respect to qi,dqi
  void GetVelocity(Real qi,Real dqi,const Vector3& p,Vector3& vel) const;
  void GetAngularVelocity(Real dqi,Vector3& omega) const;

  ///Jacobian (orientation,position) of a point (in frame 0) with respect to qi
  void GetJacobian(Real qi,const Vector3& p,Vector3& Jo,Vector3& Jp) const;
  void GetOrientationJacobian(Vector3& Jo) const;
  void GetPositionJacobian(Real qi,const Vector3& p,Vector3& Jp) const;

  //Position jacobian of points in frame 0 w.r.t. i 
  void GetJacobian(Real qi,Frame3D& J) const; 
  //Position jacobian of points in frame j w.r.t. i
  void GetJacobian(Real qi,const Frame3D& Tj_World,Frame3D& J) const; 
  void GetWorldInertia(Matrix3& inertiaWorld) const;
  void GetWorldCOM(Vector3& comWorld) const { T_World.mulPoint(com,comWorld); }

  Type type; /// Indicates the type of joint- revolute, prismatic
  Vector3 w; /// The axis of rotation/translation (in local frame)
  Real mass;
  Vector3 com; /// The center of mass (in local frame)
  Matrix3 inertia; /// The inertia matrix (in local frame)
  /// Temporary - holds the current state of local to world transformation
  Frame3D T_World;


Robot (Modeling/Robot.h)
bool InJointLimits(const Config& q) const;
virtual bool SelfCollision(Real distance=0);


  Robot : public RobotWithGeometry
    string name;
    vector<string> geomFiles;   ///< geometry file names (used in saving)
    vector<ManagedGeometry> geomManagers; ///< geometry loaders (speeds up loading)
    Vector accMax;   ///< conservative acceleration limits, used by DynamicPath
    vector<RobotJoint> joints;
    vector<RobotJointDriver> drivers;
    vector<string> linkNames;
    vector<string> driverNames;

  <- RobotWithGeometry

    SelfCollision()
    DrawGL()
    DrawLinkGL(int i)
    int LinkIndex(char *) GetBody|GetLink function
    virtual bool SelfCollision(Real distance=0);


  <- <- RobotDynamics3D 

    Vector dq;   ///< current velocity
    Vector velMin,velMax; ///< velocity limits
    Vector torqueMax;     ///< torque limits
    Vector powerMax;      ///< Power=|torque||velocity| limits

    //B*ddq + C*dq = fext
      //ddq from fext
      void CalcAcceleration(Vector& ddq, const Vector& fext);
      //fext from ddq
      void CalcTorques(const Vector& ddq, Vector& fext);


  <- <- <- RobotKinematics3D 

    Vector3 GetCOM()
    GetTotalMass()
    std::vector<RobotLink3D> links;
    Config q;  //! DO NOT set directly, use UpdateConfig!
    Vector qMin,qMax;   ///< joint limits

    /// sets the current config q and updates frames
    void UpdateConfig(const Config& q);
    /// based on the values in q, update the frames T
    void UpdateFrames();
    bool InJointLimits(const Config& q) const;

    //Force Field acts on rigid link i and induces a wrench on its COM
    // wrench on COM of link i induces a wrench on CS of robot. 
    // F = J^t w | w=(torque,force)
    void GetWrenchTorques(const Vector3& torque, const Vector3& force, int i, Vector& F) const;


  <- <- <- <- Chain
    //on-chain/off-chain idea goes here:
    void GetChildList(std::vector<std::vector<int> >& children) const;


Anygeometry: AnyCollisionQuery
RobotLink3D (KrisLibrary/robotics/RobotLink3d.h
  Type type; {revolute,prismatic}
  Vector3 w;
  Real mass;
  Vector3 com;
  Matrix3 inertia;

-------------------------------------------------------------------------------
INTERFACE
-------------------------------------------------------------------------------

  Controls the communication between frontend and backend
  Frontend  (The GUI, viewer, interactions, dynamic simulation, drawGL)
    GenericGUIBase (GenericGUI.h)
  Backend (The world and its entities)
    GenericBackendBase (GenericGUI.h)

-------------------------------------------------------------------------------
BACKEND [Interface/*GUI.h]
-------------------------------------------------------------------------------
  GenericBackendBase [GenericGUI.h] 
    bool GenericGUIBase::SendGLViewport(int x,int y,int w,int h)

  <- MouseDragBackend [NavigationGUI.h] 
  <- <- GLNavigationBackend [NavigationGUI.h] 
          Camera::Viewport viewport; viewport.x .y .w .h 
          OnGLRender()
            RenderWorld()

  <- <- <- WorldGUIBackend [WorldGUI.h] (loader for RobotWorld)
              RenderWorld()
                drawCoords(0.1);

  <- <- <- <- SimGUIBackend [SimulationGUI.h] (add functions to display dynamics,i.e. wrenches, torques, contacts etc)
                RenderWorld()
                  world->terrains[i]->DrawGL();
                  world->rigidObjects[i]->DrawGL();
                  world->robotViews[i].DrawLink_World(j);

  <- <- <- <- <- SimTestBackend [SimTestGUI.h] (more functions to interact with robot, add forces, etc)
                  RenderWorld()
                    world->robotViews[r].SetColors(desiredColor);
                    world->robotViews[r].Draw();
                    world->robotViews[r].SetAppearance(oldAppearance);

-------------------------------------------------------------------------------
GUI
-------------------------------------------------------------------------------
  GLUIProgramBase [KrisLibrary/GLdraw/GLUIProgram.h]
  Run()
  int Run(const char *window_title="OpenGL Viewer",unsigned int displayMode=0);

  <- GLUIGUI : GenericGUIBase, GLUIProgramBase [Interface/GLUIGUI.h]

  <- <- GLScreenshotProgram<BaseGUI> : public BaseGUI

  <- <- <- GLUISimTestGUI : GLScreenshotProgram<GLUIGUI>
          Initialize()








adding new widgets: 
Creating button: 
Connecting button: button has to be connected with render drawing method => MapButtonToggle("draw_bbs",&drawBBs);


%%inline void DrawGLTris(const
%%                                                                                                              
%%{
%%  glBegin(GL_TRIANGLES);
%%  for(size_t i=0;i<mesh.tris.size();i++) {
%%  | Math3D::Vector3 normal =
%%  | glNormal3v(normal);
%%  | glVertex3v(mesh.verts[mesh.tris[i].a]);
%%  | glVertex3v(mesh.verts[mesh.tris[i].b]);
%%  | glVertex3v(mesh.verts[mesh.tris[i].c]);
%%  }
%%  glEnd();
%%}





-------------------------------------------------------------------------------
VIEW
-------------------------------------------------------------------------------
  drawing routines for all entities defined in RobotWorld
-------------------------------------------------------------------------------

Actual drawing happens in KrisLibrary/GLdraw/GeometryAppearance.cpp
KrisLibrary/GLdraw/drawextra.h

-------------------------------------------------------------------------------
SIMULATION
-------------------------------------------------------------------------------
  ode simulation files 
  everything related to the actual dynamical simulation
  EntryFile : WorldSimulation.h
-------------------------------------------------------------------------------

WorldSimulation
  double time

  /// anything contact forces/torques, where are the contacts etc goes here
  ODEContactList* GetContactList(int aid,int bid);
  Vector3 ContactForce(int aid,int bid=-1);

  // major players
  ODESimulator odesim; //your gateway to ODE geometrix
  RobotWorld *world;

  ODERobot GetRobot(int id); //get the real robot (you cannot and should not
    control that, but can be used for initial placement procedures)

-------------------------------------------------------------------------------
CONTACTS
-------------------------------------------------------------------------------

  Hold (a single robot link-env contact with 1 or more contact points)
  Stance (a set of holds)
  Grasp (a set of holds with some dofs fixed)

-------------------------------------------------------------------------------
CSPACE
-------------------------------------------------------------------------------

  CSpace (Krislibrary/planning/cspace.h)
    //Generic CSpace
    void Sample(Config& x);
    bool IsFeasible(const Config&);

  <- ExplicitCSpace (KrisLibrary/planning/ExplicitCspace.h)
    //N-obstacles CSpace
    bool IsFeasible(const Config&,int obstacle);
    EdgePlanner* LocalPlanner(const Config& a,const Config& b,int obstacle);
    int NumObstacles();
    void GetInfeasibleNames(const Config& q,std::vector<std::string>& names);

  <- <- SingleRobotCSpace  (Klampt/Planning/RobotCSpace.h)
    //Single Robot 
    vector<pair<int,int> > collisionPairs;
    bool CheckCollisionFree();
    WorldPlannerSettings* settings;
    RobotWorld& world;
    int index; ##robot number
    Robot* GetRobot&();


  <- <- <- <- SingleRobotCSpace2 (Klampt/Planning/RobotCSpace.h)
    //Single robot + fixed dofs available
    IgnoreCollisions(int,int)
    FixDof(int,double)

  <- <- <- <- <- ContactCSpace (Klampt/Planning/ContactCSpace.h)
    //Single Robot in contact with environment
    vector<IKGoal> contactIK;
    void AddContact(const IKGoal& goal);
    void RemoveContact(int link);
    bool SolveContact(int numIters=0,Real tol=0);
-------------------------------------------------------------------------------
KINODYNAMIC CSPACE
-------------------------------------------------------------------------------

  CSpace (Krislibrary/planning/cspace.h)
    void Sample(Config& x);
    bool IsFeasible(const Config&);

  <- KinodynamicCSpace (KrisLibrary/planning/KinodynamicCSpace.h)

  <- <- IntegratedKinodynamicCSpace : public KinodynamicCSpace


-------------------------------------------------------------------------------
MOTION PLANNER
-------------------------------------------------------------------------------

(KrisLibrary/planning/MotionPlanner.h)

RoadmapPlanner 
TreeRoadmapPlanner
  <- RRTPlanner
  <- <- BidirectionalRRTPlanner

(KrisLibrary/planning/AnyMotionPlanner.h)
  MotionPlannerFactory factory;
  factory.type="rrt"
  MotionPlannerInterface = factory.create(CSpace)




-------------------------------------------------------------------------------
LOAD/SAVE RESOURCE (KrisLibrary/utils/ResourceLibrary.h)
-------------------------------------------------------------------------------

  Modeling/Resources.h

    BasicResources (vector,transform,config)
    GraspResources

-------------------------------------------------------------------------------
MATH
 * The elements can be accessed as (i,j) for i,j in [0,3].

  WARNING: [i][j] = (j,i) !! DO NOT USE [i][j]
-------------------------------------------------------------------------------
 Infinity
  double dInf
  Real Inf

 Krislibrary/math3d/primitives.h
  class Vector2;
  class Vector3;
  class Vector4;
  class Matrix2;
  class Matrix3;
  class Matrix4;
  class RigidTransform2D;
  class RigidTransform;
  +IO functionality!

  - class Matrix3
    inline void setRotateX(Real rads);  ///<sets the matrix that rotates ccw by rads around the x axis
    inline void setRotateY(Real rads);  ///<sets the matrix that rotates ccw by rads around the x axis
    inline void setRotateZ(Real rads);  ///<sets the matrix that rotates ccw by rads around the x axis

  setIdentity()
  setZero()


 Krislibrary/math/Vectortemplate.h
  typedef class VectorTemplate<float> fVector;
  typedef class VectorTemplate<double> dVector;
  typedef class VectorTemplate<Complex> cVector;
  typedef VectorTemplate<Real> Vector;
    T dot(const MyT&) const;
    T dotSelf() const;
    T norm() const;
    T normSquared() const;
    T distance(const MyT&) const;
    T distanceSquared(const MyT&) const;
    T minElement(int* index=NULL) const;
    T maxElement(int* index=NULL) const;
    T minAbsElement(int* index=NULL) const;
    T maxAbsElement(int* index=NULL) const;

-------------------------------------------------------------------------------
PATH
-------------------------------------------------------------------------------

MilestonePath (KrisLibrary/planning/path.h)
  const Config& Start()
  const Config& End()
  bool IsFeasible();
  int Eval(Real t, Config& c) const;

MultiPath (Modeling/MultiPath.h)
  Load(string);
  Save(string);
  bool IsValid();
  Real StartTime() const;
  ///Returns the end time of the path.  If untimed, the end time is 1.
  Real EndTime() const;
  Real Duration() const;
  int Evaluate(Real time,Vector& q,Vector& v)

-------------------------------------------------------------------------------
Controller
-------------------------------------------------------------------------------

Control/Controller.h
-------------------------------------------------------------------------------
World Simulation
-------------------------------------------------------------------------------

 Every robot has an associated ControlledRobotSimulator class
(Simulation/ControllerSimulator.h)

It contains Robot, ODERobot, and RobotController. Also we can get a Sensor class
and set a Command Class:

  Robot* robot;
  ODERobot* oderobot;
  RobotController* controller;
  RobotMotorCommand command;
  RobotSensors sensors;

We need to reinit this one after changing the driver!


-------------------------------------------------------------------------------
TODO
-------------------------------------------------------------------------------

 [x] solve IK for frame-env contact points
 [x] Can't change SIMROBOT anymore, what happened!?
 [x] place robot directly(!) at IK computed solution and THEN start sim 
 [x] place robot feet on floor
 [x] plan path between A and B
 [x] extract milestones between A and B from path
 [x] execute path in GUI
 [x] retime path
 [x] execute trajectory in GUI
 [x] add limits/selfcollision/collision checks to IK
 [x] visualize path in GUI (i.e. visualize the individual link paths)
 [x] swept volume? (for irr paper)
 [x] swept volume transparent without the blueish background
 [x] Move hand such that a set of fingertip points is fulfilled
 [x] set color to link in contact
 [x] importing/exporting blender models? how to best design your own environments? [needs .tri to blender importer. there is none (only for some other tri files). maybe better to convert to dae (collada) ?]
 [x] why does planning fail with 1 additional joint see sentinel
 [x] disable backface culling to display backoriented triangles (just use rigidobject, they are non-culled)
 [x] MultiPath is using linear interpolation between keyframes. However on SO(3)
we need a different interpolation due to the gluing of the charts. Check if
something like that is already implemented, see GeodesicManifold/DynamicPath.
Just use KinodynamicMilestonePath instead of MultiPath!
 [x] add widgets for planning to gui
 [x] setup kinodynamic planning problem
 [x] control in kinodynamic planning converges to wrong direction
 [x] refactor draw methods in gui.cpp
 [x] make a Klampt Interface where to set all properties like background color etc
 [x] screenshots x_X?
 [x] refactor planner settings
 [x] save kinodynamicmilestonepath to file 
 [x] outsource serialized tree to seperate file
 [x] save motion planner class plus tree and path
 [x] krrt: no forward simulation towards goal (was wrong init rot)
 [x] save/load GUI state including Motion Planning Equipment
 [x] Display/Undisplay Rigid Bodies (to visualize tree)
 [x] implement edge visualization in KrisLibrary/GLDraw/GeometryAppearance.cpp
 [x] install krislib with ompl support (didn't link ompl in klampt lib and this lib)
 [x] ompl does not read the joint limits
 [x] make ompl planners available 
 [x] remove this orange line from origin to p_init
 [x] ompl converts cspace to realvectorspace R, but we need a compound space SE(3)xQ => make own ompl interface
 [x] enable ompl geometric planners
 [x] add omplapp interface to load meshes + collision detection (check omplapp/SE3RigidBodyPlanning.cpp)
      (/git/ompl/omplapp-1.3.0-Source/demos/SE3RigidBodyPlanning)
 [x] enable ompl kinodynamic planners
 [x] move planner components to planner/
 [x] make button to disable/enable mesh and disable/enable faces of mesh
 [x] run ompl PDST/KPIECE /w def proj
 [x] compute irreducible projection from SE(3) path
 [x] GUI: save current robot state too, not only init/goal of planner
 [x] remove torsion while computing irreducible projection
 [x] reimplement irreducible projection in cpp, make it cleaner
 [x] refactor path_pwl_euclid
 [x] compute projection irreducible for N branches
 [x] extend environment by a new pipe upward curved plus box connector
 [x] make the environment easier to compute for rigid body planning (widen the inner hole maybe!?)
 [x] outsource swept volume to seperate elements file
 [x] check distance function in OMPL -- why is it different depending on number of DOFs?
 [x] find distance to goal for planner output OMPL (how approximate is the solution)
 [x] toggle mesh/faces of objects with keyboard
 [x] add edges to planner tree visualization
 [ ] add directions again in draw serialized tree after culling nodes
 [ ] boost graph instead of serialized tree?
 [ ] Button to save/load GUI state including Motion Planning Equipment
 [ ] create planner_klampt outsourcing klampt planning structure
 [ ] solve IK for arbitrary rob-env contact points
 [ ] grasp an actual object
 [ ] sample grasps for object and compute IK (findGrasp method)
 [ ] make/break contact events => compute transition paths
 [ ] execute transition paths 
 [ ] change viewpoint internally
 [ ] Compute Force Closure Grasp from points
 [ ] Compute SE constraints, what is GIWC equivalent?
 [ ] smoothing after path planning
 [ ] refactor kinodynamic planner to make it independent from path planner
 [ ] decompose GUI into sweptvolumeGUI and forcefieldGUI 
 [ ] save all swept volumes when saving GUI, rewrite all Load/Save functions
 [ ] refactor planner -> use PlannerOutput to store path/roadmap and use
PlannerOutput as Input to GUI to shadow the internal things. Also put the
plannersettings into the xml, so that we can load planner+start/goal config
without recompiling. Delete the whole plannersetup folder!
 [ ] update to klampt-0.7
 [ ] visualize wrench cone at contact
 [ ] restructure GUI to use GUIVariables


-- abstractions (longterm goals)

 [ ] Needs switch to QT, the file loader from GLUI seems not to work properly. Also the graphics are quite bad. 
 [x] be able to design landscapes/fancy environments and import them to simulator

 [ ] be able to load different landscapes/robots from simulator, plus start/goal
configs, and be able to run different algorithms to find a solution. Then be
able to save/delete solution paths. So that we can display several output paths
as swept volumes simultaneously
      [ ] be able to load different landscapes + plannersettings from simulator 
      [x] screenshots
      [x] display plannersettings (text+start/goal configs)

 [ ] do benchmark planning from inside the simulator by clicking together
algorithms and #runs and duration. Have a default benchmarking plus dump
everything to nice pdf graph / latex table.
 [ ] have ability to retime a path inside simulator, then display the
output over time inside the simulator. 
 [ ] be able to deform path inside simulator. Ability to load paths from file,
then display them, then deform them, then to save those paths. 
 [ ] visualize planner tree with millions of nodes without lags (cull points somehow)
 [ ] have vim-keybindings to quickly move around, save/load, screenshots,
display tree/start/goal/swept volumes, do planning
 [ ] EnvironmentLoader should be merged with Backend, so that we can load/save inside
 [ ] use TAB to access different modes: simulation <-> Desired Pose (change goal) blender-like controls?
 [ ] better swept volume visualization (have an aggregate or convex hull of successive positions)
      andreas dziegielewski http://acg.cs.tau.ac.il/projects/swept-volume/project-page seems promising
 [ ] making a safe static contact

-- wrench fields

 [x] create arbitrary force fields in ODE simulator
 [x] create force field visualization and visualize its effect on each link
 [x] add arrows to visualize flow of power
 [x] forces on link => make them better looking like contact wrenches
 [x] compute and display distance between links and terrain
 [x] visualize COM separately in box to quickly see wrenches attacking robot.
 [x] let force be specificable in xml file, uniform, box, uniform inside rigid object, radial from source,
maelstrom from source, and any combination of that. Test with moving robot
around and visualize wrenches on each link plus wrench on COM
COM should retain orientation equal to origin so that we can see forces from
 [x] cylindrical FF
 [x] visualize min dist between link and terrain
 [x] add custom controller loop 
 [x] visualize force ellipsoid at each point
 [x] simulate snake, make sure there are no glitches
 [ ] enable velocity induced FF, drag force, magnetic force, etc
 [ ] apply force to rigidObjects and other robots in the scene
 [ ] composite force fields: intersection and union
 [ ] add constraint to a FF to be inside a given rigid object
 [ ] [URGENT] Plan one path /w speed profile using OMPL, send to controller, execute in the simulator, have perfect path following behavior
   [x] return only pointers in ompl_space, make a factory
   [x] finalize kinodynamic space
   [x] simulate jet propulsion
   [x] implement tangentbundle integrator
   [x] *** execute/simulate kinodynamic path (use jet propulsion)
   [x] torque values are SO(3) x R3 in controller, but should be R3xSO(3).  Why?
   [x] error: driver 0 is not in PID mode. Why?
   [x] jet propulsion not implemented yet (see RobotJointDriver)
   [x] jet propulsion acts on global coordinate frame, not locally on robot link
   [x] torques not being set properly (robot should move with random torques)
   [x] segfault /w single rigid body
   [x] drivers and actuators do not match up. zero joints = zero actuators, therefore segfault. where are the actuators created?
   [x] display the jet propulsion wrenches to verify
   [x] why does robot move when disabling force fields? (does not happen after reset!)
   [ ] display all torques applied
   [ ] *** do kinodynamic planning /w torque constraints on fibre bundle
=>>   [ ] fix propagation function
      [ ] forward simulation is wrong on tangent bundle
      [ ] calcacceleration returns values on fixed joint
      [ ] feels like momentum is ignored by propagation function. 
   [x] gl error when drawing planning tree
    
   [x] reset: delete com window
   [x] reset: go back to init pos not xml config
   [x] add start velocity plannersettings
   [x] outsource duration time, algorithm name and epsilon goal (xml plannersettings)
   [x] put geometricOMPLcspace together with principal fibre bundle, do the same for kinodynamic
   [ ] ** flow following by forward simulating a PID controlled device
   [ ] OMPL_SPACE remove hardcoded se3 vector fields (and put them into xml, urdf or so)
   [ ] include FF in tangentbundle integrator
   [ ] *** do kinodynamic planning /w FF
   [ ] ** visualize path speed profile (reuse python display and display in topp)
 [ ] * replace propagation by undulatory motions along each axis, but how would that work?
 [ ] make cspace ompl work with zero-dimensional shape space
 
 [ ] put all the loader stuff into separate folder each with one file

-- important

 [x] self collisions occuring when simulating atlas in Klampt. ODERobot
correctly determines that collision occurs. But why is it not avoided? maybe
force too strong? but then terrain would be permeated, too.
    Simulation/settings.h: const static bool gRobotSelfCollisionsEnabled = true;
 [ ] simulator crash if forces are too high and selfcollision is enabled ---
happens if we apply a force which overcomes the self-collision and creates
overlapping meshes. solution: avoid forces higher than ?? or increase
self-collision forces?
 [x] reset not working anymore
 [x] reset goes back to wrong position
 [x] reset: momentum is not set back to zero 
 [ ] reset: crash when plotting joint values
 [ ] kernel panic after movie creation
   [ ] got another kernel panic after displaying torque based jet propulsion
 [ ] retreat simulation

-- unnamed abstractions paper

 [x] compute and display distance between links and terrain
 [x] make small 3-leg spider robot, only contacts
 [ ] use some balance controller
 [x] design cave environment
 [x] force is applied even with 000 force field (didn't remove se3drivers)
 [ ] ompl:rrt applied to workspace planner, rework the planning interface
    [ ] do planning with timelimit and no success return
    [ ] extract tree, display all 
    [ ] compute homotopy classes

 [ ] planning with two robot entities inner/outer SV
    [ ] make cspace with two robots, inherit from kinodynamiccspace, make robot + outer shell 

-- redesign UI
 [ ] create three hotkey groups: Env Manipulation, Path Manipulation, Robot Manipulation and Simulation
 [ ] level planning
   [ ] visualize level tree
   [ ] visualize level path
   [ ] visualize level all paths
 [ ] have different numbers to highlight/show different planner outputs. This
way we could build a hierarchical visualization

[ ] planner should retain option to do standard kino/geo planning with ompl
[ ] planner needs refactoring: new folders validator/integrator. new class setup
which takes settings and produces a cspace and an algorithm taking
validator/integrator into account. This setup file should then be replaced by
Hplanner, so we need to give it more meaningful name 

[ ] adjust algo such that spheres do not intersect (too many clustered on one point) -> cvx decomp?
[ ] make sure it works with -wall, -mars, and -cave.
[ ] fix spider urdf

[ ] get new idea for going down one level
 [ ] cylinder -> hole example (can easily be compared to ompl, has many
variations already included in ompl and would nicely act as a ground truth
example)
 [ ] cylinder -> free space as comparison (do not check if start and goal can be
connected, or use that as a ground truth benchmark)
 [ ] corner element -> hole

-- Decompose robot into CVX regions. If not, add cvx regions and rigid joints.
-- Choose one link, the one with min cum reach. 
-- Compute max internal sphere. do planning level 1. This is for connectivity.
-- Compute max internal capsule. do planning level 2? This is for orientation
connectivity.
-- compute 1-level layer limbs. I.e. take the root link, add those limbs. At
least one reachable set has to be in contact.

We might lose orientation connectivity because a passage is too curved.


[ ] !! FIX LEVEL0: spheres are too near which cost too much computation. Also spheres
are still computed kinodynamically. this is the foundation, there cannot be any
overload crap. Don't sacrifice completeness, however.
  [x] make computation geometric
  [ ] enforce space constraint
  [ ] compute principal LEVEL0 path 
    [x] fix one graph representation (e.g. boostgraph) which has lots of
algorithms associated (at least dykstra)


[x] install SBL lib
[x] compute homology groups (HG) of SC
[x] make bottle planning possible
[ ] changing between visuals changes colors/linewidth of other visuals, but shouldn't.
[ ] take simplicial complex (SC), compute retraction.
[ ] visualize different retraction levels of SC
[ ] compute representative paths of some cycles

[ ] visualize internal holes

[x] ompl cannot deal with zero dimensions
[ ] compute shortest paths in each homotopy class
[ ] tab through all layers of a simplicial complex with [tab] or other key
[ ] compute retraction (GUDHI or CGAL)
[ ] orientation limits are not respected OMPL


What objects to increase complexity?

nunchaku (1dof revolute SE(3) x S1)
irregular shaped links (non-convex) (SE(3))

[x] remove zero measure dimensions from OMPL (i.e. map them to lower space
before starting OMPL, there are always problems with that)
[ ] there is no way to enforce bounds on SO(3), maybe we need to decompose it somehow
[ ] have one complete system for rigid link: add arbitrary nested robots.
compute shortest paths. Iterate through all solutions.

[x] magneto: 2-dof, 2 magnet robot
[ ] simulate a magnetic-contact

good idea to add it. several new problems:
[ ] how to define contact points and add arbitrary force when in contact?
[ ] how to make and break contacts
[ ] how to adapt sphere/capsule to new structure. it is completely different,
how can that work?


brainstorming:
  we give up arbitrary positioning. further restriction. now we need zero
distance to environment.
 is there maybe an even easier shape? maybe without any joints, or just one
joint?
 how about a spring which is automatically moving along? this would be SE(2)?
bwd/fwd motions, but no internal shape shifts.

 the two joints could be made such that leg1/leg3 are zero. Then there would be
no shape changes. then for the free foot we would have rotational symmetry.
cspace would collapse to line segment.
