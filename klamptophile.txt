-------------------------------------------------------------------------------
MODELING
-------------------------------------------------------------------------------
  A container for all the entities which we use
  Robot, Terrain, RigidObject, MultiPath
  EntryFile: World.h
  
  Note: 
    Robot corresponds to the "desired" yellowish robot in simulation; to put
    the real robot exactly at a position can be done over ODERobot
    WorldSimulation->GetRobot(). This is only for starting purposes of course.
    Control acts on ODEWorldSimulationRobot, while all the kinematic
    solutions/setconfig act on Yellow Robot. 
    Be sure to update the frames or use UpdateConfig to set the robot
-------------------------------------------------------------------------------

RobotWorld (World.h) contains 
  Robot, Terrain, RigidObject, MultiPath!
  Names, Ids
  Load/Save XML

World -> Terrain -> ManagedGeometry -> DrawGL()
-> GLDraw::GeometryAppearance -> DrawGL() ->
  

Robot (Modeling/Robot.h)
  Robot : public RobotWithGeometry
    string name;
    vector<string> geomFiles;   ///< geometry file names (used in saving)
    vector<ManagedGeometry> geomManagers; ///< geometry loaders (speeds up loading)
    Vector accMax;   ///< conservative acceleration limits, used by DynamicPath
    vector<RobotJoint> joints;
    vector<RobotJointDriver> drivers;
    vector<string> linkNames;
    vector<string> driverNames;

  <- RobotWithGeometry

    SelfCollision()
    DrawGL()
    DrawLinkGL(int i)
    int LinkIndex(char *) GetBody|GetLink function

  <- <- RobotDynamics3D 

    Vector dq;   ///< current velocity
    Vector velMin,velMax; ///< velocity limits
    Vector torqueMax;     ///< torque limits
    Vector powerMax;      ///< Power=|torque||velocity| limits

    //B*ddq + C*dq = fext
      //ddq from fext
      void CalcAcceleration(Vector& ddq, const Vector& fext);
      //fext from ddq
      void CalcTorques(const Vector& ddq, Vector& fext);


  <- <- <- RobotKinematics3D 

    GetCOM()
    GetTotalMass()
    std::vector<RobotLink3D> links;
    Config q;  //! DO NOT set directly, use UpdateConfig!
    Vector qMin,qMax;   ///< joint limits

    /// sets the current config q and updates frames
    void UpdateConfig(const Config& q);
    /// based on the values in q, update the frames T
    void UpdateFrames();
    bool InJointLimits(const Config& q) const;

    //Force Field acts on rigid link i and induces a wrench on its COM
    // wrench on COM of link i induces a wrench on CS of robot. 
    // F = J^t w | w=(torque,force)
    void GetWrenchTorques(const Vector3& torque, const Vector3& force, int i, Vector& F) const;


  <- <- <- <- Chain
    //on-chain/off-chain idea goes here:
    void GetChildList(std::vector<std::vector<int> >& children) const;


RobotLink3D (KrisLibrary/robotics/RobotLink3d.h
  Type type; {revolute,prismatic}
  Vector3 w;
  Real mass;
  Vector3 com;
  Matrix3 inertia;

-------------------------------------------------------------------------------
INTERFACE
-------------------------------------------------------------------------------

  Controls the communication between frontend and backend
  Frontend  (The GUI, viewer, interactions, dynamic simulation, drawGL)
    GenericGUIBase (GenericGUI.h)
  Backend (The world and its entities)
    GenericBackendBase (GenericGUI.h)

-------------------------------------------------------------------------------
BACKEND [Interface/*GUI.h]
-------------------------------------------------------------------------------
  GenericBackendBase [GenericGUI.h] 
    bool GenericGUIBase::SendGLViewport(int x,int y,int w,int h)

  <- MouseDragBackend [NavigationGUI.h] 
  <- <- GLNavigationBackend [NavigationGUI.h] 
          Camera::Viewport viewport; viewport.x .y .w .h 
          OnGLRender()
            RenderWorld()

  <- <- <- WorldGUIBackend [WorldGUI.h] (loader for RobotWorld)
              RenderWorld()
                drawCoords(0.1);

  <- <- <- <- SimGUIBackend [SimulationGUI.h] (add functions to display dynamics,i.e. wrenches, torques, contacts etc)
                RenderWorld()
                  world->terrains[i]->DrawGL();
                  world->rigidObjects[i]->DrawGL();
                  world->robotViews[i].DrawLink_World(j);

  <- <- <- <- <- SimTestBackend [SimTestGUI.h] (more functions to interact with robot, add forces, etc)
                  RenderWorld()
                    world->robotViews[r].SetColors(desiredColor);
                    world->robotViews[r].Draw();
                    world->robotViews[r].SetAppearance(oldAppearance);

-------------------------------------------------------------------------------
GUI
-------------------------------------------------------------------------------
  GLUIProgramBase [KrisLibrary/GLdraw/GLUIProgram.h]
  Run()
  int Run(const char *window_title="OpenGL Viewer",unsigned int displayMode=0);

  <- GLUIGUI : GenericGUIBase, GLUIProgramBase [Interface/GLUIGUI.h]

  <- <- GLScreenshotProgram<BaseGUI> : public BaseGUI

  <- <- <- GLUISimTestGUI : GLScreenshotProgram<GLUIGUI>
          Initialize()








adding new widgets: 
Creating button: 
Connecting button: button has to be connected with render drawing method => MapButtonToggle("draw_bbs",&drawBBs);




-------------------------------------------------------------------------------
VIEW
-------------------------------------------------------------------------------
  drawing routines for all entities defined in RobotWorld
-------------------------------------------------------------------------------

Actual drawing happens in KrisLibrary/GLdraw/GeometryAppearance.cpp
KrisLibrary/GLdraw/drawextra.h

-------------------------------------------------------------------------------
SIMULATION
-------------------------------------------------------------------------------
  ode simulation files 
  everything related to the actual dynamical simulation
  EntryFile : WorldSimulation.h
-------------------------------------------------------------------------------

WorldSimulation
  double time

  /// anything contact forces/torques, where are the contacts etc goes here
  ODEContactList* GetContactList(int aid,int bid);
  Vector3 ContactForce(int aid,int bid=-1);

  // major players
  ODESimulator odesim; //your gateway to ODE geometrix
  RobotWorld *world;

  ODERobot GetRobot(int id); //get the real robot (you cannot and should not
    control that, but can be used for initial placement procedures)

-------------------------------------------------------------------------------
CONTACTS
-------------------------------------------------------------------------------

  Hold (a single robot link-env contact with 1 or more contact points)
  Stance (a set of holds)
  Grasp (a set of holds with some dofs fixed)

-------------------------------------------------------------------------------
CSPACE
-------------------------------------------------------------------------------

  CSpace (Krislibrary/planning/cspace.h)
    //Generic CSpace
    void Sample(Config& x);
    bool IsFeasible(const Config&);

  <- ExplicitCSpace (KrisLibrary/planning/ExplicitCspace.h)
    //N-obstacles CSpace
    bool IsFeasible(const Config&,int obstacle);
    EdgePlanner* LocalPlanner(const Config& a,const Config& b,int obstacle);
    int NumObstacles();
    void GetInfeasibleNames(const Config& q,std::vector<std::string>& names);

  <- <- SingleRobotCSpace  (Klampt/Planning/RobotCSpace.h)
    //Single Robot 
    vector<pair<int,int> > collisionPairs;
    bool CheckCollisionFree();
    WorldPlannerSettings* settings;
    RobotWorld& world;
    int index; ##robot number
    Robot* GetRobot&();


  <- <- <- <- SingleRobotCSpace2 (Klampt/Planning/RobotCSpace.h)
    //Single robot + fixed dofs available
    IgnoreCollisions(int,int)
    FixDof(int,double)

  <- <- <- <- <- ContactCSpace (Klampt/Planning/ContactCSpace.h)
    //Single Robot in contact with environment
    vector<IKGoal> contactIK;
    void AddContact(const IKGoal& goal);
    void RemoveContact(int link);
    bool SolveContact(int numIters=0,Real tol=0);
-------------------------------------------------------------------------------
KINODYNAMIC CSPACE
-------------------------------------------------------------------------------

  CSpace (Krislibrary/planning/cspace.h)
    void Sample(Config& x);
    bool IsFeasible(const Config&);

  <- KinodynamicCSpace (KrisLibrary/planning/KinodynamicCSpace.h)

  <- <- IntegratedKinodynamicCSpace : public KinodynamicCSpace


-------------------------------------------------------------------------------
MOTION PLANNER
-------------------------------------------------------------------------------

(KrisLibrary/planning/MotionPlanner.h)

RoadmapPlanner 
TreeRoadmapPlanner
  <- RRTPlanner
  <- <- BidirectionalRRTPlanner

(KrisLibrary/planning/AnyMotionPlanner.h)
  MotionPlannerFactory factory;
  factory.type="rrt"
  MotionPlannerInterface = factory.create(CSpace)




-------------------------------------------------------------------------------
LOAD/SAVE RESOURCE (KrisLibrary/utils/ResourceLibrary.h)
-------------------------------------------------------------------------------

  Modeling/Resources.h

    BasicResources (vector,transform,config)
    GraspResources

-------------------------------------------------------------------------------
MATH
 * The elements can be accessed as (i,j) for i,j in [0,3].

  WARNING: [i][j] = (j,i) !! DO NOT USE [i][j]
-------------------------------------------------------------------------------
 Infinity
  double dInf
  Real Inf

 Krislibrary/math3d/primitives.h
  class Vector2;
  class Vector3;
  class Vector4;
  class Matrix2;
  class Matrix3;
  class Matrix4;
  class RigidTransform2D;
  class RigidTransform;
  +IO functionality!

  - class Matrix3
    inline void setRotateX(Real rads);  ///<sets the matrix that rotates ccw by rads around the x axis
    inline void setRotateY(Real rads);  ///<sets the matrix that rotates ccw by rads around the x axis
    inline void setRotateZ(Real rads);  ///<sets the matrix that rotates ccw by rads around the x axis

  setIdentity()
  setZero()


 Krislibrary/math/Vectortemplate.h
  typedef class VectorTemplate<float> fVector;
  typedef class VectorTemplate<double> dVector;
  typedef class VectorTemplate<Complex> cVector;
  typedef VectorTemplate<Real> Vector;
    T dot(const MyT&) const;
    T dotSelf() const;
    T norm() const;
    T normSquared() const;
    T distance(const MyT&) const;
    T distanceSquared(const MyT&) const;
    T minElement(int* index=NULL) const;
    T maxElement(int* index=NULL) const;
    T minAbsElement(int* index=NULL) const;
    T maxAbsElement(int* index=NULL) const;

-------------------------------------------------------------------------------
PATH
-------------------------------------------------------------------------------

MilestonePath (KrisLibrary/planning/path.h)
  const Config& Start()
  const Config& End()
  bool IsFeasible();
  int Eval(Real t, Config& c) const;

MultiPath (Modeling/MultiPath.h)
  Load(string);
  Save(string);
  bool IsValid();
  Real StartTime() const;
  ///Returns the end time of the path.  If untimed, the end time is 1.
  Real EndTime() const;
  Real Duration() const;
  int Evaluate(Real time,Vector& q,Vector& v)


-------------------------------------------------------------------------------
TODO
-------------------------------------------------------------------------------

 [x] solve IK for frame-env contact points
 [x] Can't change SIMROBOT anymore, what happened!?
 [x] place robot directly(!) at IK computed solution and THEN start sim 
 [x] place robot feet on floor
 [x] plan path between A and B
 [x] extract milestones between A and B from path
 [x] execute path in GUI
 [x] retime path
 [x] execute trajectory in GUI
 [x] add limits/selfcollision/collision checks to IK
 [x] visualize path in GUI (i.e. visualize the individual link paths)
 [x] swept volume? (for irr paper)
 [x] swept volume transparent without the blueish background
 [x] Move hand such that a set of fingertip points is fulfilled
 [x] set color to link in contact
 [x] importing/exporting blender models? how to best design your own environments? [needs .tri to blender importer. there is none (only for some other tri files). maybe better to convert to dae (collada) ?]
 [x] why does planning fail with 1 additional joint see sentinel
 [x] disable backface culling to display backoriented triangles (just use rigidobject, they are non-culled)
 [x] MultiPath is using linear interpolation between keyframes. However on SO(3)
we need a different interpolation due to the gluing of the charts. Check if
something like that is already implemented, see GeodesicManifold/DynamicPath.
Just use KinodynamicMilestonePath instead of MultiPath!
 [x] add widgets for planning to gui
 [x] setup kinodynamic planning problem
 [x] control in kinodynamic planning converges to wrong direction
 [x] refactor draw methods in gui.cpp
 [ ] solve IK for arbitrary rob-env contact points
 [ ] grasp an actual object
 [ ] sample grasps for object and compute IK (findGrasp method)
 [ ] make/break contact events => compute transition paths
 [ ] execute transition paths 
 [ ] change viewpoint internally
 [ ] Compute Force Closure Grasp from points
 [ ] Compute SE constraints, what is GIWC equivalent?
 [ ] smoothing after path planning
 [ ] make a Klampt Interface where to set all properties like background color etc
 [ ] better swept volume visualization (have an aggregate or convex hull of successive positions)
 [ ] screenshots x_X?
 [ ] refactor kinodynamic planner to make it independent from path planner
 [ ] refactor planner settings
 [x] save kinodynamicmilestonepath to file 
 [x] outsource serialized tree to seperate file
 [x] save motion planner class plus tree and path
 [x] krrt: no forward simulation towards goal (was wrong init rot)
 [x] save/load GUI state including Motion Planning Equipment
 [x] Display/Undisplay Rigid Bodies (to visualize tree)
 [x] implement edge visualization in KrisLibrary/GLDraw/GeometryAppearance.cpp
 [x] install krislib with ompl support (didn't link ompl in klampt lib and this lib)
 [x] ompl does not read the joint limits
 [x] make ompl planners available 
 [ ] add directions again in draw serialized tree after culling nodes
 [ ] make the controller work without gravity on SE(3)
 [ ] execute kinodynamic path
 [ ] remove this orange line from origin to p_init
 [ ] Button to save/load GUI state including Motion Planning Equipment
 [x] ompl converts cspace to realvectorspace R, but we need a compound space SE(3)xQ => make own ompl interface
 [x] enable ompl geometric planners
 [x] add omplapp interface to load meshes + collision detection (check omplapp/SE3RigidBodyPlanning.cpp)
      (/git/ompl/omplapp-1.3.0-Source/demos/SE3RigidBodyPlanning)
 [x] enable ompl kinodynamic planners
 [ ] create planner_klampt outsourcing klampt planning structure
 [x] move planner components to planner/
 [x] make button to disable/enable mesh and disable/enable faces of mesh
 [ ] refactor planner 
 [ ] boost graph instead of serialized tree
 [ ] find distance to goal for planner output OMPL (how approximate is the solution)
 [ ] run ompl PDST/KPIECE /w def proj
 [ ] compute irreducible projection from SE(3) path
 [ ] extend environment by a new pipe upward curved plus box connector
 [ ] GUI: save current robot state too, not only init/goal of planner
