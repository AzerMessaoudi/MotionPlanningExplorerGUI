-------------------------------------------------------------------------------
TODO
-------------------------------------------------------------------------------

 [x] solve IK for frame-env contact points
 [x] Can't change SIMROBOT anymore, what happened!?
 [x] place robot directly(!) at IK computed solution and THEN start sim 
 [x] place robot feet on floor
 [x] plan path between A and B
 [x] extract milestones between A and B from path
 [x] execute path in GUI
 [x] retime path
 [x] execute trajectory in GUI
 [x] add limits/selfcollision/collision checks to IK
 [x] visualize path in GUI (i.e. visualize the individual link paths)
 [x] swept volume? (for irr paper)
 [x] swept volume transparent without the blueish background
 [x] Move hand such that a set of fingertip points is fulfilled
 [x] set color to link in contact
 [x] importing/exporting blender models? how to best design your own environments? [needs .tri to blender importer. there is none (only for some other tri files). maybe better to convert to dae (collada) ?]
 [x] why does planning fail with 1 additional joint see sentinel
 [x] disable backface culling to display backoriented triangles (just use rigidobject, they are non-culled)
 [x] MultiPath is using linear interpolation between keyframes. However on SO(3)
we need a different interpolation due to the gluing of the charts. Check if
something like that is already implemented, see GeodesicManifold/DynamicPath.
Just use KinodynamicMilestonePath instead of MultiPath!
 [x] add widgets for planning to gui
 [x] setup kinodynamic planning problem
 [x] control in kinodynamic planning converges to wrong direction
 [x] refactor draw methods in gui.cpp
 [x] make a Klampt Interface where to set all properties like background color etc
 [x] screenshots x_X?
 [x] refactor planner settings
 [x] save kinodynamicmilestonepath to file 
 [x] outsource serialized tree to seperate file
 [x] save motion planner class plus tree and path
 [x] krrt: no forward simulation towards goal (was wrong init rot)
 [x] save/load GUI state including Motion Planning Equipment
 [x] Display/Undisplay Rigid Bodies (to visualize tree)
 [x] implement edge visualization in KrisLibrary/GLDraw/GeometryAppearance.cpp
 [x] install krislib with ompl support (didn't link ompl in klampt lib and this lib)
 [x] ompl does not read the joint limits
 [x] make ompl planners available 
 [x] remove this orange line from origin to p_init
 [x] ompl converts cspace to realvectorspace R, but we need a compound space SE(3)xQ => make own ompl interface
 [x] enable ompl geometric planners
 [x] add omplapp interface to load meshes + collision detection (check omplapp/SE3RigidBodyPlanning.cpp)
      (/git/ompl/omplapp-1.3.0-Source/demos/SE3RigidBodyPlanning)
 [x] enable ompl kinodynamic planners
 [x] move planner components to planner/
 [x] make button to disable/enable mesh and disable/enable faces of mesh
 [x] run ompl PDST/KPIECE /w def proj
 [x] compute irreducible projection from SE(3) path
 [x] GUI: save current robot state too, not only init/goal of planner
 [x] remove torsion while computing irreducible projection
 [x] reimplement irreducible projection in cpp, make it cleaner
 [x] refactor path_pwl_euclid
 [x] compute projection irreducible for N branches
 [x] extend environment by a new pipe upward curved plus box connector
 [x] make the environment easier to compute for rigid body planning (widen the inner hole maybe!?)
 [x] outsource swept volume to seperate elements file
 [x] check distance function in OMPL -- why is it different depending on number of DOFs?
 [x] find distance to goal for planner output OMPL (how approximate is the solution)
 [x] toggle mesh/faces of objects with keyboard
 [x] add edges to planner tree visualization
 [ ] Button to save/load GUI state including Motion Planning Equipment
 [ ] solve IK for arbitrary rob-env contact points
 [ ] grasp an actual object
 [ ] sample grasps for object and compute IK (findGrasp method)
 [ ] make/break contact events => compute transition paths
 [ ] execute transition paths 
 [ ] change viewpoint internally
 [ ] Compute Force Closure Grasp from points
 [ ] Compute SE constraints, what is GIWC equivalent?
 [ ] smoothing after path planning
 [ ] refactor kinodynamic planner to make it independent from path planner
 [ ] decompose GUI into sweptvolumeGUI and forcefieldGUI 
 [ ] save all swept volumes when saving GUI, rewrite all Load/Save functions
 [ ] refactor planner -> use PlannerOutput to store path/roadmap and use
PlannerOutput as Input to GUI to shadow the internal things. Also put the
plannersettings into the xml, so that we can load planner+start/goal config
without recompiling. Delete the whole plannersetup folder!
 [ ] update to klampt-0.7
 [ ] visualize wrench cone at contact
 [ ] restructure GUI to use GUIVariables


-- abstractions (longterm goals)

 [ ] Needs switch to QT, the file loader from GLUI seems not to work properly. Also the graphics are quite bad. 
 [x] be able to design landscapes/fancy environments and import them to simulator
 [ ] be able to load different landscapes/robots from simulator, plus start/goal
configs, and be able to run different algorithms to find a solution. Then be
able to save/delete solution paths. So that we can display several output paths
as swept volumes simultaneously
      [x] be able to load different landscapes + plannersettings from simulator 
      [x] screenshots
      [x] display plannersettings (text+start/goal configs)

 [ ] do benchmark planning from inside the simulator by clicking together
algorithms and #runs and duration. Have a default benchmarking plus dump
everything to nice pdf graph / latex table.
 [ ] have ability to retime a path inside simulator, then display the
output over time inside the simulator. 
 [ ] be able to deform path inside simulator. Ability to load paths from file,
then display them, then deform them, then to save those paths. 
 [x] have vim-keybindings to quickly move around, save/load, screenshots,
display tree/start/goal/swept volumes, do planning
 [x] EnvironmentLoader should be merged with Backend, so that we can load/save inside
 [ ] use TAB to access different modes: simulation <-> Desired Pose (change goal) blender-like controls?
 [ ] better swept volume visualization (have an aggregate or convex hull of successive positions)
      andreas dziegielewski http://acg.cs.tau.ac.il/projects/swept-volume/project-page seems promising
 [ ] making a safe static contact

-- wrench fields

 [x] create arbitrary force fields in ODE simulator
 [x] create force field visualization and visualize its effect on each link
 [x] add arrows to visualize flow of power
 [x] forces on link => make them better looking like contact wrenches
 [x] compute and display distance between links and terrain
 [x] visualize COM separately in box to quickly see wrenches attacking robot.
 [x] let force be specificable in xml file, uniform, box, uniform inside rigid object, radial from source,
maelstrom from source, and any combination of that. Test with moving robot
around and visualize wrenches on each link plus wrench on COM
COM should retain orientation equal to origin so that we can see forces from
 [x] cylindrical FF
 [x] visualize min dist between link and terrain
 [x] add custom controller loop 
 [x] visualize force ellipsoid at each point
 [x] simulate snake, make sure there are no glitches
 [ ] enable velocity induced FF, drag force, magnetic force, etc
 [ ] apply force to rigidObjects and other robots in the scene
 [ ] composite force fields: intersection and union
 [ ] add constraint to a FF to be inside a given rigid object
 [ ] [URGENT] Plan one path /w speed profile using OMPL, send to controller, execute in the simulator, have perfect path following behavior
   [x] return only pointers in ompl_space, make a factory
   [x] finalize kinodynamic space
   [x] simulate jet propulsion
   [x] implement tangentbundle integrator
   [x] *** execute/simulate kinodynamic path (use jet propulsion)
   [x] torque values are SO(3) x R3 in controller, but should be R3xSO(3).  Why?
   [x] error: driver 0 is not in PID mode. Why?
   [x] jet propulsion not implemented yet (see RobotJointDriver)
   [x] jet propulsion acts on global coordinate frame, not locally on robot link
   [x] torques not being set properly (robot should move with random torques)
   [x] segfault /w single rigid body
   [x] drivers and actuators do not match up. zero joints = zero actuators, therefore segfault. where are the actuators created?
   [x] display the jet propulsion wrenches to verify
   [x] why does robot move when disabling force fields? (does not happen after reset!)
   [ ] display all torques applied
   [ ] *** do kinodynamic planning /w torque constraints on fibre bundle
=>>   [ ] fix propagation function
      [ ] forward simulation is wrong on tangent bundle
      [ ] calcacceleration returns values on fixed joint
      [ ] feels like momentum is ignored by propagation function. 
   [x] gl error when drawing planning tree
    
   [x] reset: delete com window
   [x] reset: go back to init pos not xml config
   [x] add start velocity plannersettings
   [x] outsource duration time, algorithm name and epsilon goal (xml plannersettings)
   [x] put geometricOMPLcspace together with principal fibre bundle, do the same for kinodynamic
   [ ] ** flow following by forward simulating a PID controlled device
   [ ] OMPL_SPACE remove hardcoded se3 vector fields (and put them into xml, urdf or so)
   [ ] include FF in tangentbundle integrator
   [ ] *** do kinodynamic planning /w FF
   [ ] ** visualize path speed profile (reuse python display and display in topp)
 [ ] * replace propagation by undulatory motions along each axis, but how would that work?
 [ ] make cspace ompl work with zero-dimensional shape space
 
 [ ] put all the loader stuff into separate folder each with one file

-- important

 [x] self collisions occuring when simulating atlas in Klampt. ODERobot
correctly determines that collision occurs. But why is it not avoided? maybe
force too strong? but then terrain would be permeated, too.
    Simulation/settings.h: const static bool gRobotSelfCollisionsEnabled = true;
 [ ] simulator crash if forces are too high and selfcollision is enabled ---
happens if we apply a force which overcomes the self-collision and creates
overlapping meshes. solution: avoid forces higher than ?? or increase
self-collision forces?
 [x] reset not working anymore
 [x] reset goes back to wrong position
 [x] reset: momentum is not set back to zero 
 [ ] reset: crash when plotting joint values
 [ ] kernel panic after movie creation
   [ ] got another kernel panic after displaying torque based jet propulsion
 [ ] retreat simulation

-- unnamed abstractions paper

 [x] compute and display distance between links and terrain
 [x] make small 3-leg spider robot, only contacts
 [ ] use some balance controller
 [x] design cave environment
 [x] force is applied even with 000 force field (didn't remove se3drivers)
 [ ] ompl:rrt applied to workspace planner, rework the planning interface
    [ ] do planning with timelimit and no success return
    [ ] extract tree, display all 
    [ ] compute homotopy classes

 [x] planning with two robot entities inner/outer SV
    [x] make cspace with two robots, inherit from kinodynamiccspace, make robot + outer shell 

-- redesign UI
 [ ] create three hotkey groups: Env Manipulation, Path Manipulation, Robot Manipulation and Simulation
 [x] level planning
   [x] visualize level tree
   [x] visualize level path
   [x] visualize level all paths
 [ ] have different numbers to highlight/show different planner outputs. This
way we could build a hierarchical visualization

[ ] planner needs refactoring: new folders validator/integrator. new class setup
which takes settings and produces a cspace and an algorithm taking
validator/integrator into account. This setup file should then be replaced by
Hplanner, so we need to give it more meaningful name 
[ ] adjust algo such that spheres do not intersect (too many clustered on one point) -> cvx decomp?
[ ] make sure it works with -wall, -mars, and -cave.
[x] fix spider urdf

[ ] get new idea for going down one level
 [ ] cylinder -> hole example (can easily be compared to ompl, has many
variations already included in ompl and would nicely act as a ground truth
example)
 [ ] cylinder -> free space as comparison (do not check if start and goal can be
connected, or use that as a ground truth benchmark)
 [ ] corner element -> hole

[x] install SBL lib
[x] compute homology groups (HG) of SC
[x] make bottle planning possible
[x] visualize internal holes
[x] changing between visuals changes colors/linewidth of other visuals, but shouldn't.
[x] ompl cannot deal with zero dimensions
[ ] compute retraction (GUDHI or CGAL)
[ ] orientation limits are not respected OMPL

[x] remove zero measure dimensions from OMPL (i.e. map them to lower space
before starting OMPL, there are always problems with that)
[ ] there is no way to enforce bounds on SO(3), maybe we need to decompose it somehow
[x] have one complete system for rigid link: add arbitrary nested robots.
compute shortest paths. Iterate through all solutions.

[x] magneto: 2-dof, 2 magnet robot
[x] reset does not work on all robots
[x] remove orientation sampling for rotational invariant shapes
[x] bottle requires different planner because physics is different: innerouter vs. normal

Contacts 
[ ] How to make the contact decisions inside the controller?
[ ] most important point is how the hierarchy would work with a contact point
[ ] simulate a magnetic-contact. read klampt tutorial about humanoid robot with
infinite force contact. how to selectively activate/deactivate?
[ ] how to define contact points and add arbitrary force when in contact?
[ ] how to make and break contacts
[ ] how to adapt sphere/capsule to new structure. it is completely different, how can that work?
[ ] can we design a controller which moves M0 around a great arc of an arbitrary sphere?
[ ] do the same, but for M2

General
[ ] Simulator: make planner run on separate threads
[ ] add drawFace/drawEdge to terrain XML file
[ ] draw functions should be stored in map (string/string) structure to be
easier accessible in GUI. If we like to add one variable, we should only change
maybe keybindings and oncommand in GUI. everything else is ideally done
automatically.
[ ] have <gui></gui> environment to set variables
[ ] make objects transparent
[x] test RRT for visibility check between two paths
[x] test on 6 environments: 
  [x] sphere
  [x] cuboid
  [x] double cuboid
  [x] triple T grill (see jaillet 2008)
  [x] forest of cylinders on a flat surface
  [x] 3D lattice cuboid
[x] visualize tree by text output (and indicate which nodes are where)
[x] smooth path
[x] interpolate path
[x] extend ompl to plan with an input path constraint (sublevel planning)
[x] visualize tree with this velocity window thing
[x] make onetopic modifier general applicable to any config/space
[x] create [L-shape] in elongated environment to show failure case of Zhang approach
[x] layer 2 sometimes returns infeasible paths for capsule => fundamental issue
[x] XML: every algorithm should have its own time/epsilon/additional properties


[ ] more sophisticated [graph visualization]; using viewpoint to get fixed 3d position
[ ] sometimes [two nearby paths are not reduced], investigate that (update definition of equivalence first)
[ ] incorporate [sufficient conditions], visualize that nodes are feasible, use
some interpolation to get shortest path in pocket
[ ] more challenging environments
  [ ] forest with steep ruggy terrain
[ ] orientation of capsule definitely not correct. needs investigating.

[ ] make a list of environments, their picture and what this environment is
designed to show (and who came up with the environment)
[ ] XML restructioning
  [ ] make xml with default planner settings, which fill in all fields with
  default values and with a default algorithm. 
  [ ] make xml with default GUI settings. 
  [ ] let GUI settings be able to set shortcut keys for each setting

[ ] visualize all vertices of one onetopic covering

